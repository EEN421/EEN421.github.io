#  KQL Toolbox #5: ğŸ“§ Phishing & Malware Hunting ğŸ”

## Welcome back to KQL Toolbox ğŸ‘‹

In KQL Toolbox #1, we learned how to measure Microsoft Sentinel ingest and translate it into real operational dollars. In KQL Toolbox #2, we identified which data sources were driving that cost. In KQL Toolbox #3, we drilled all the way down to specific Event IDs, accounts, and devices generating noise. In KQL Toolbox #4, we shifted from whatâ€™s expensive to what changed â€” helping you pinpoint where billable log volume spiked or dropped and why. _All of those entries were about understanding your telemetryâ€™s shape, its motion, and its financial impact â€” which is crucial for cost governance and operational hygiene._

But once youâ€™ve got data quality, cost, and delta analysis in your toolkit, one question always pops up: _â€œOkayâ€¦ now what threats are actually showing up in my telemetry?â€_ This is where **phishing and malware hunting** steps in... Email is the #1 vector in most real-world intrusions. Whether itâ€™s a clever social-engineering campaign or a payload-laden attachment trying to evade detection, getting fast, prioritized insight into who is being targeted, who the most aggressive senders are, and which users or domains are seeing the most malicious activity is mission-critical for defenders.

So in this weekâ€™s KQL Toolbox entry, we take your hunting game to the next level:
- We filter email telemetry for phishing-classified events,
- Tally up which recipients are getting hammered the hardest,
- Identify the sender domains driving that activity,
- And add severity buckets so you can triage, prioritize, and act fast.

Instead of just collecting logs, youâ€™ll now be extracting actionable threat signals that help you spot campaigns, escalate investigations, and harden your defenses where it matters most. _Whether youâ€™re defending an enterprise email stack or building out detections in Microsoft Defender XDR / Advanced Hunting, this set of queries gives you a practical starting point for turning noisy mail telemetry into targeted threat insights._

âš¡ _This isnâ€™t just counting emails â€” **itâ€™s hunting the ones that matter**_.

<br/>

![](/assets/img/KQL%20Toolbox/5/KQL5-1.png)

<br/>

## Today's KQL helps you identify â€œWhich recipients are getting hit with the most phishing emails, and which sender domains are responsible â€” with a quick severity label so I can triage fast?â€

We accomplish that by:
- filtering email telemetry to phishing-tagged events,
- counting them per RecipientEmailAddress + SenderFromDomain,
- assigning â€œseverityâ€ buckets based on count thresholds,
- sorting and returning the top 10 highest-volume combos,
- formatting output for human readability.

<br/><br/>

# Query 1 â€” Identify top recipients of phishing emails and categorizes severity based on volume
```kql
EmailEvents
| where ThreatTypes has "Phish"
| summarize PhishCount = count() by RecipientEmailAddress, SenderFromDomain
// Assign severity level indicators based on PhishCount
| extend SeverityIndicator = case(
                                 PhishCount >= 500,
                                 "ğŸ”¥ Extreme Volume",
                                 PhishCount >= 200,
                                 "ğŸ”´ Critical Volume",
                                 PhishCount >= 100,
                                 "ğŸŸ  Major Volume",
                                 PhishCount >= 50,
                                 "ğŸŸ¡ Moderate Volume",
                                 "ğŸŸ¢ Low Volume"
                             )
// Apply color coding to PhishCount
| extend CountColor = case(
                          PhishCount >= 500,
                          "ğŸ”¥",
                          PhishCount >= 200,
                          "ğŸ”´",
                          PhishCount >= 100,
                          "ğŸŸ ",
                          PhishCount >= 50,
                          "ğŸŸ¡",
                          "ğŸŸ¢"
                      )
// Sort by the highest volume of phishing emails received
| top 10 by PhishCount desc
// Improve column naming for readability
| project
    ["Recipient Email"] = RecipientEmailAddress, 
    ["Sender Domain"] = SenderFromDomain, 
    ["Phishing Emails Received"] = strcat(CountColor, " ", PhishCount),
    ["Severity"] = SeverityIndicator
```

<br/>

![](/assets/img/KQL%20Toolbox/5/KQL5-screen1.png)

<br/>

### [ğŸ”—Get the query here](https://github.com/EEN421/KQL-Queries/blob/Main/Top%20Blocked%20Phishing%20Events.kql)

<br/><br/>

## Line-by-line technical breakdown ğŸ‘‡

## `EmailEvents`
This is your starting table.

In Microsoft Defender XDR advanced hunting, EmailEvents represents email message-level telemetry (think: â€œan email event existsâ€ plus metadata). Itâ€™s not attachment events and not URL click events â€” those are other tables (commonly EmailAttachmentInfo, EmailUrlInfo, etc., depending on schema).

Key point: youâ€™re starting at the event grain of â€œemail message activityâ€, which is appropriate for â€œvolume receivedâ€.

<br/>

## `| where ThreatTypes has "Phish"`
This filters the dataset down to only rows where the ThreatTypes field contains "Phish".

`has` is a token-based search operator. Itâ€™s optimized for â€œcontains word/tokenâ€. Itâ€™s usually a good fit when the field is a string that may contain multiple threat labels (e.g., Phish, Malware, Spam, etc.) or a semi-structured list. If ThreatTypes is something like "Phish;Spam" or "Spam, Phish", this will still match.

What this means operationally:
- Youâ€™re relying on whatever detection/classification pipeline populated ThreatTypes.
- This is not â€œuser reported phishâ€ by default; itâ€™s â€œthe system labeled this email as phish-relatedâ€.

> Gotcha: If your environment uses different labeling (example: â€œPhishingâ€ vs â€œPhishâ€), this filter may undercount. If ThreatTypes can be empty or null sometimes, those simply wonâ€™t match.

<br/>

## `| summarize PhishCount = count() by RecipientEmailAddress, SenderFromDomain`

What `summarize` does:
- It groups rows by the fields listed after by.
- For each group, it calculates aggregations (here: count()).
- It outputs one row per group.

Weâ€™re grouping by TWO fields:
- `RecipientEmailAddress`
- `SenderFromDomain`

So the output is: **â€œTop recipient + sender-domain pairsâ€**

> âš ï¸ Thatâ€™s important: _**If one user gets 1,000 phish from 50 different domains (20 each), they will not appear as 1,000. Theyâ€™ll appear as many smaller rows.**_ Conversely, if one domain hammers one user repeatedly, that combo will jump to the top â€” which is usually what you want if youâ€™re trying to block/suppress a campaign source.

<br/>

## `PhishCount = count()` 
Counts rows in each group and give it the alias **PhishCount** for readability.

<br/>

## `| extend SeverityIndicator = case( ... )`
`Extend` adds a new calculated column (or overwrites an existing one if the same name is used). Here, youâ€™re creating a string label based on thresholds.

<br/>

### How `case()` works in KQL:

`case(condition1, value1, condition2, value2, ..., defaultValue)` --> evaluates conditions in order...
- First match wins
- If none match, it returns the default.

<br/>

Our logic is as follows...

```kql
PhishCount >= 500 â†’ "ğŸ”¥ Extreme Volume"

else if >= 200 â†’ "ğŸ”´ Critical Volume"

else if >= 100 â†’ "ğŸŸ  Major Volume"

else if >= 50 â†’ "ğŸŸ¡ Moderate Volume"

else â†’ "ğŸŸ¢ Low Volume"
```

<br/>

- ğŸ’¡ **Why the order matters:** If you put `PhishCount >= 50 first`, then a `PhishCount=500` row would match that first and never reach the â€œExtremeâ€ label. Our ordering is _highest threshold first._

<br/>

- ğŸ” **Why this is useful:** Now your output can be read by humans quickly without doing mental math: â€œOkay, thatâ€™s ğŸ”¥/ğŸ”´ â€” I should look at that first.â€

<br/>

## `| extend CountColor = case( ... )`
This is basically the same thresholds again, but returning a single emoji marker.

We now have:
- `SeverityIndicator` (emoji + label)
- `CountColor` (emoji only)

This is redundant on purpose because we use `CountColor` later to decorate the numeric `count` column - _This is a common â€œSOC dashboard trickâ€: you donâ€™t need conditional formatting support if you embed the indicator into the string._

<br/>

## `| top 10 by PhishCount desc`
`top` is like using `sort by ...` followed by `| take 10`, but optimized and concise in a single command.

- by PhishCount desc sorts highest first.
- top 10 returns only the first 10 rows.

> ğŸ’¡ Important detail: This is â€œtop 10 recipient+domain pairsâ€ _after aggregation._ So the output is the 10 highest-volume hotspots.

<br/>

## `| project ...`
`project` shapes the final output columns: _**rename, reorder, compute new display values,** and drop everything else._

We're doing four things here:

- 1.) `["Recipient Email"] = RecipientEmailAddress`
    - Renames RecipientEmailAddress to â€œRecipient Emailâ€.
    - Square-bracket quoting is required because the column name contains spaces. This is KQLâ€™s friendly display-name style.
    
    <br/>

- 2.) `["Sender Domain"] = SenderFromDomain`
    - Same idea: user-friendly heading.

<br/>

- 3.) `["Phishing Emails Received"] = strcat(CountColor, " ", PhishCount)`
    - This is the â€œpretty outputâ€ trick.
    - `strcat()` concatenates values into a string.
    - Put the emoji first, then a space, then the count.
    - So instead of 245, you get: "ğŸ”´ 245"
    > - âš ï¸ **Gotcha**: Because this becomes a string, you canâ€™t sort numerically on this display column anymore. But we already sorted earlier using PhishCount, so weâ€™re fine. If you ever wanted to chart this later, youâ€™d keep numeric PhishCount as a separate projected column too. Check out my earlier discussion on this nuance in PREVIOUS KQL Toolbox #.

<br/>

- 4.) `["Severity"] = SeverityIndicator`
    - Final friendly severity label.
    - What the output actually represents
    - Each returned row means:
        - Recipient X received N phishing-labeled email events
        - specifically from Sender Domain Y
        - and N falls into a severity bucket

<br/>

So this is extremely good for:
- spotting targeted users being hammered by a specific campaign domain
- identifying domains to block (or to investigate for spoofing / lookalike patterns)
- identifying users who might need extra protections/training (or are being specifically targeted)

<br/>

### Practical SOC interpretation tips:

High volume to one recipient from one domain can indicate:
- a campaign repeatedly attempting delivery
- repeated re-sends with minor variations
- a compromised sender domain blasting the org
- a lookalike domain you should block fast

<br/>

High volume spread across many domains might indicate:
- â€œrecipient is a public-facing mailboxâ€ (careers@, info@, support@)

<br/>

## Why this query matters:
This query helps defenders zero in on specific attacker-to-victim paths by showing where phishing pressure is disproportionately high from particular domains toward particular users. Instead of just knowing a user is targeted, you see who is doing the targeting â€” which enables faster decisions about domain blocks, mail transport rules, and investigation priorities. In real investigations, repeated hits from the same domain often signal a concerted campaign or automated blast infrastructure thatâ€™s worth immediate containment action.

<br/>

## âš¡ Steps to Operationalize:
Identify users who are disproportionately targeted by phishing campaigns so you can prioritize protection, awareness, and monitoring.
- Run cadence: Weekly (SOC hygiene) and monthly (trend review)
- Visualize: Sentinel Workbook showing:
    - Top recipients
    - % of total phishing volume
    - Trend over time
- Baseline: Establish a â€œnormalâ€ recipient distribution; alert only on new or sudden targeting shifts

<br/>

## âš”ï¸ SOC Actions:
**Validate whether targets are:**
- Executives
- Finance / payroll
- IT admins
- Shared mailboxes

<br/>

**Cross-reference with:**
- MFA status
- Conditional Access policies
- Past incidents or credential-theft attempts

<br/>

## ğŸ›¡ï¸ Defensive Controls to Trigger:
- Tighten Conditional Access for heavily targeted users
- Enable enhanced phishing protections (Safe Links, Safe Attachments)
- Add targeted awareness training (not org-wide spam)

<br/>

ğŸ‘‰ **Outcome:** You shift from â€œeveryone gets phishedâ€ to focused protection for high-risk users, reducing blast radius and response fatigue.

<br/>

![](/assets/img/KQL%20Toolbox/5/KQL5-2.png)

<br/><br/>

# Query #2 â€” â€œWhich recipients are getting the most phishing emails (by volume), and how severe is the targeting?â€
In the last query, we answered a very actionable question: â€œWhich recipient + sender domain pairs are generating the most phishing volume?â€ That pairing is clutch when youâ€™re trying to quickly identify a campaign source and decide what to block, quarantine, or hunt further.

But sometimes you need to zoom out and ask a simpler, more strategic question: _â€œWho are my top targeted users overall â€” regardless of where the phish is coming from?â€_

Thatâ€™s exactly what this next query does. Instead of splitting counts across sender domains, it rolls everything up by recipient, giving you a clean â€œTop 10 most targeted mailboxesâ€ view thatâ€™s perfect for triage, VIP protection, training prioritization, and focus-based investigation.

```kql
EmailEvents
| where ThreatTypes has "Phish"
| summarize PhishCount = count() by RecipientEmailAddress
// Assign severity level indicators based on PhishCount
| extend SeverityIndicator = case(
                                 PhishCount >= 500,
                                 "ğŸ”¥ Extreme Target",
                                 PhishCount >= 200,
                                 "ğŸ”´ Critical Target",
                                 PhishCount >= 100,
                                 "ğŸŸ  Major Target",
                                 PhishCount >= 50,
                                 "ğŸŸ¡ Moderate Target",
                                 "ğŸŸ¢ Low Target"
                             )
// Apply color coding to PhishCount
| extend CountColor = case(
                          PhishCount >= 500,
                          "ğŸ”¥",
                          PhishCount >= 200,
                          "ğŸ”´",
                          PhishCount >= 100,
                          "ğŸŸ ",
                          PhishCount >= 50,
                          "ğŸŸ¡",
                          "ğŸŸ¢"
                      )
// Sort by the highest volume of phishing emails received
| top 10 by PhishCount desc
// Improve column naming for readability
| project
    ["Recipient Email"] = RecipientEmailAddress, 
    ["Phishing Emails Received"] = strcat(CountColor, " ", PhishCount),
    ["Severity"] = SeverityIndicator
```

Itâ€™s a â€œwho is being targeted the mostâ€ ranking query â€” and itâ€™s intentionally recipient-centric, not campaign-centric.

<br/>

![](/assets/img/KQL%20Toolbox/5/KQL5-screen2.png)

<br/>

### [ğŸ”— Grab the full query here](https://github.com/EEN421/KQL-Queries/blob/Main/Top%20Phishing%20Targets.kql)

<br/><br/>

# Line-by-line technical breakdown ğŸ‘‡

## `EmailEvents`
This is your source table â€” the email telemetry backbone.

Each row represents an email-related event record with fields that can include:
- sender / recipient addressing
- delivery actions
- threat classifications (like your ThreatTypes)
- message metadata

<br/>

## `| where ThreatTypes has "Phish"`

This is our filter: only **phishing-labeled** email events survive.

Why this matters:
- Everything downstream (counts, top 10, severity) is only as good as this filter.
- Youâ€™re trusting the platformâ€™s classification pipeline that populates ThreatTypes.

Why `has` is used:
- It matches tokens inside a larger string (helpful if ThreatTypes contains multiple labels like "Phish;Spam").
- Itâ€™s typically more efficient/appropriate than a fuzzy â€œcontains-likeâ€ approach when the field is token-ish.

<br/>

## `| summarize PhishCount = count() by RecipientEmailAddress`

This is the big change vs the previous query.

What summarize is doing: 
- Groups all phishing events by RecipientEmailAddress
- Counts how many phishing email events each recipient had
- Outputs one row per recipient

What this solves:
- This gives you the true total volume per user.

<br/>

So instead of: _Ian got 20 from domainA, 15 from domainB, 40 from domainCâ€¦_

You now get: _Ian got 75 total phishing emails._

<br/>

This is excellent for:
- identifying who needs extra protection (VIP mailbox, exec, finance/AP)
- spotting mailboxes that are hammered (info@, jobs@, support@)
- focusing investigations (â€œWhy is THIS one mailbox getting hit so hard?â€)

<br/>

## `| extend SeverityIndicator = case( ... )`

Weâ€™re creating a severity label called SeverityIndicator.

Key mechanics:
- extend adds a new calculated column
- case() evaluates conditions top-to-bottom (first match wins)
- The last string is the default if none match

Your thresholds:

| Count  | Interpretation       |
| ------ | -------------------- |
| >= 500 | ğŸ”¥ Extreme Target    |
| >= 200 | ğŸ”´ Critical Target   |
| >= 100 | ğŸŸ  Major Target      |
| >= 50  | ğŸŸ¡ Moderate Target   |
| else   | ğŸŸ¢ Low Target        |

> ğŸ‘† Adjust the **Count** thresholds to the size of your organization so this actually means something!


<br/>

## `| extend CountColor = case( ... )`

This repeats the same threshold logic, but returns a single emoji.

So later, you can build output like:
- ğŸ”´ 245
- ğŸŸ¡ 61

> This is a â€œ**portable conditional formatting**â€ trick â€” especially handy when results are pasted into tickets, email, or screenshots.

<br/>

## Next, we rank the hottest targets with `| top 10 by PhishCount desc`

This returns only the 10 highest **PhishCount** recipients. Result expectation: This produces our â€œTop 10 targeted usersâ€ list.

<br/>

## Now we convert technical column names into human-friendly headers with `| project ...`

project is where we â€œfinalizeâ€ the output.

- `["Recipient Email"] = RecipientEmailAddress` --> Renames the column to a clean display name with spaces.
- `["Phishing Emails Received"] = strcat(CountColor, " ", PhishCount)` --> This builds a formatted string like:
    - ğŸ”¥ 612
    - ğŸŸ  143

> Important nuance (again):
This makes the displayed value a string. Thatâ€™s fine here because:
- we already did our numeric sort using PhishCount
- weâ€™re optimizing output for human consumption

> Check out this discussion in this PRIOR KQL TOOLBOX Article #.

<br/>

## `["Severity"] = SeverityIndicator`

Adds the labeled bucket we created earlier.

What the output represents (plain English)... Each row now means:
- â€œThis recipient received N phishing-classified emails in the query time window (whatever your hunting UI defaults to), and N maps to this severity bucket.â€

_This is a clean **â€œwhoâ€™s getting hammeredâ€** scoreboard._

<br/><br/>

## Why this query matters:
Some users are magnets for malicious email â€” executives with publicly exposed addresses, shared inboxes like **info@** or **support@**, and compromised accounts included on internal lists. This query collapses sender domains to show total phishing exposure per recipient, giving defenders a cleaner view of whoâ€™s under the most attack regardless of source. This perspective is useful for prioritization when time or resources are limited.

## âš¡ Steps to Operationalize: 
Surface sender domains responsible for sustained or repeated phishing attempts.
- Run cadence: Daily for hunting, weekly for reporting
- Track: Domain recurrence and growth rate (new vs persistent domains)
- Tag Domains as:
    - Known malicious
    - Newly emerging
    - Opportunistic spray-and-pray

<br/>

## âš”ï¸ SOC Actions:
- **Enrich domains with:**
    - WHOIS age
    - Threat intel feeds
    - Previous block history

<br/>

- **Identify:**
    - Campaign reuse
    - Infrastructure rotation patterns

<br/>

## ğŸ›¡ï¸ Defensive Controls to Trigger:
- **Block domains at:**
    - Microsoft 365 Defender
    - Secure Email Gateway
    - DNS layer
- **Create temporary watchlists** for domains showing accelerating volume

<br/>

ğŸ‘‰ **Outcome:** You move from reactive mailbox cleanup to campaign-level disruption, breaking phishing infrastructure early.

<br/>

![](/assets/img/KQL%20Toolbox/5/KQL5-3.png)

<br/><br/>

# Query #3 â€” â€œTop Threat Sender Domainsâ€

Now that weâ€™ve identified which mailboxes are being targeted most heavily, the next logical question is: _â€œOkayâ€¦ whoâ€™s doing the targeting at scale?â€_

Because protecting users is only half the battle â€” the other half is shutting down the source. This next query flips the perspective from recipient-centric to threat-infrastructure-centric, showing you which sender domains are responsible for the most phishing volume across your entire environment. Thatâ€™s exactly the view you want for:
- rapid domain blocking / allow-block policy decisions
- threat intel enrichment and clustering
- proving a campaignâ€™s scale in an incident summary (â€œthis domain hit us 800 times in 24 hoursâ€)

This query answers: _â€œWhich sender domains are responsible for the highest volume of phishing emails (as classified by the platform)?â€_

Itâ€™s a â€œtop offender domainsâ€ query â€” ideal for finding repeat infrastructure and prioritizing blocking and investigation.

<br/>

```kql 
EmailEvents
| where ThreatTypes has "Phish"
| summarize PhishCount = count() by SenderFromDomain
// Assign severity level indicators based on PhishCount
| extend SeverityIndicator = case(
                                 PhishCount >= 1000,
                                 "ğŸ”¥ Extreme Threat Domain",
                                 PhishCount >= 500,
                                 "ğŸ”´ Critical Threat Domain",
                                 PhishCount >= 200,
                                 "ğŸŸ  Major Threat Domain",
                                 PhishCount >= 100,
                                 "ğŸŸ¡ Moderate Threat Domain",
                                 "ğŸŸ¢ Low Threat Domain"
                             )
// Apply color coding to PhishCount
| extend CountColor = case(
                          PhishCount >= 1000,
                          "ğŸ”¥",
                          PhishCount >= 500,
                          "ğŸ”´",
                          PhishCount >= 200,
                          "ğŸŸ ",
                          PhishCount >= 100,
                          "ğŸŸ¡",
                          "ğŸŸ¢"
                      )
// Sort by the highest volume of phishing emails sent from a domain
| top 10 by PhishCount desc
// Improve column naming for readability
| project
    ["Sender Domain"] = SenderFromDomain, 
    ["Phishing Emails Sent"] = strcat(CountColor, " ", PhishCount),
    ["Severity"] = SeverityIndicator
```

<br/>

![](/assets/img/KQL%20Toolbox/5/KQL5-screen3.png)

<br/>

### [ğŸ”— Grab the query here](https://github.com/EEN421/KQL-Queries/blob/Main/Top%20Phishing%20Domains.kql)

<br/><br/>

## Line-by-line technical breakdown ğŸ‘‡

### `EmailEvents`

Your base email telemetry table again. Same logic as before: this table is appropriate because weâ€™re counting email events and their threat classification at message level.

<br/>

## `| where ThreatTypes has "Phish"`

Filter down to phishing-labeled email events. This keeps the analysis scoped to what the detection pipeline has already classified as phishing-related.

Why itâ€™s important here:
If you donâ€™t filter, youâ€™ll just get your â€œtop sender domains overallâ€ (which is usually dominated by normal business mail sources, marketing platforms, etc.). This where clause makes the output threat-focused.

<br/>

## `| summarize PhishCount = count() by SenderFromDomain`

This is the key shift; What summarize does here:
- Groups all phishing email events by SenderFromDomain
- Counts how many phishing-labeled events came from each sender domain
- Outputs one row per sender domain

This gives us a ranked list of domains that show up repeatedly as the apparent sender domain in phishing-tagged emails.

### Important nuance
This is â€œSenderFromDomainâ€ â€” which reflects the domain portion of the â€œFromâ€ identity as captured in telemetry. In real-world phishing:
- the visible â€œFromâ€ domain can be spoofed
- the envelope sender / return-path can differ
- the sending infrastructure might be entirely different

So treat this output as:
- highly actionable for â€œblock/suppressâ€ decisions, and
- a starting pivot point, not the only truth.

<br/>

## `| extend SeverityIndicator = case( ... )`

Now we bucket severity again, but with thresholds tuned for domain-level volume. Our thresholds are higher than the recipient query, and thatâ€™s logical:
- A single mailbox getting 200 phish is bad
- A single domain generating 500â€“1000 phish events org-wide is an â€œinfrastructure at scaleâ€ signal

Buckets:

| Count   | Interpretation              |
|---------|-----------------------------|
| >= 1000 | ğŸ”¥ Extreme Threat Domain    |
| >= 500  | ğŸ”´ Critical Threat Domain   |
| >= 200  | ğŸŸ  Major Threat Domain      |
| >= 100  | ğŸŸ¡ Moderate Threat Domain   |
| else    | ğŸŸ¢ Low Threat Domain        |

As before:
- ordering matters (highest threshold first)
- `case()` stops on first match

<br/>

## `| extend CountColor = case( ... )`

Same thresholds again, but returns only an emoji indicator. This is purely for human scan-ability in the final table.

<br/>

## `| top 10 by PhishCount desc`

This ranks domains by highest phishing volume and returns the top 10 and creates our â€œworst offendersâ€ list â€” the domains we should:
- enrich with TI (reputation / age / registration)
- see if they map to known campaigns
- evaluate for blocking at mail gateway / Defender policies

<br/>

## `| project ...`

Final formatting and cleanup.

<br/>

`["Sender Domain"] = SenderFromDomain`

Display-friendly renaming.

<br/>

`["Phishing Emails Sent"] = strcat(CountColor, " ", PhishCount)`

This creates the formatted output string like:
- ğŸ”¥ 1422
- ğŸŸ  273

> Again: string formatting is fine because sorting already happened on the numeric `PhishCount`.

<br/>

## `["Severity"] = SeverityIndicator`

This shows our bucket label. 

Each row represents: _â€œThis sender domain appeared in N phishing-classified email events (in the query time window) across the environment â€” and hereâ€™s the severity bucket based on volume.â€_

This is your top phishing domain offenders list.

<br/>

## âš¡ Steps to Operationalize 
Determine which mailboxes are being singled out across phishing campaigns â€” beyond just raw event counts.
- Run cadence: Weekly
- Correlate with Query #1 to confirm whether:
    - High targeting = high engagement
    - Or simply high exposure
- Track changes over time:
    - New users appearing
    - Sudden targeting of dormant accounts

<br/>

## âš”ï¸ SOC Actions:
- **Investigate:**
    - Mailbox forwarding rules
    - Inbox rule abuse
    - Credential-phishing success indicators

<br/>

- **Prioritize users for:**
    - Threat hunting
    - Password resets
    - Session revocation (if required)

<br/>

## ğŸ›¡ï¸ Defensive Controls to Trigger:
- Temporary mailbox-level alerting for repeat targets
- Enhanced logging for targeted users during active campaigns
- Focused incident response playbooks

<br/>

ğŸ‘‰ **Outcome:** You identify human choke points in phishing campaigns instead of treating phishing as a generic email problem.

<br/>

![](/assets/img/KQL%20Toolbox/5/KQL5-4.png)

<br/><br/>

# Bonus Discussion: â€œOkayâ€¦ what about malware email?â€

Up to this point, weâ€™ve been treating phishing like a volume-and-targeting problem: whoâ€™s getting hammered, and which domains are doing the hammering. But in the real world, phish is often just the delivery vehicle â€” the â€œclick thisâ€ lure â€” while malware email is the â€œpayload problem.â€

So as a bonus lens, this next query pivots from phish targeting to:

â€œWhich recipients are receiving malware-labeled emails, from which domains, and how is that trending day-by-day?â€

Thatâ€™s a really practical add-on because itâ€™s inherently more â€œincident-yâ€ â€” malware emails tend to correlate more directly with containment actions and escalation.

``` kql
EmailEvents
| where ThreatTypes has "Malware"
| summarize MalwareEmailsQuarantined = count() by bin(Timestamp, 1d), RecipientEmailAddress, SenderFromDomain
| order by Timestamp desc
```

<br/>

![](/assets/img/KQL%20Toolbox/5/KQL5-screen4.png)

<br/>

### [ğŸ”— Grab the full KQL here](https://github.com/EEN421/KQL-Queries/blob/Main/Top%20Blocked%20Malware%20Email%20Events.kql)

<br/><br/>

This query answers: 
- When (by day) are malware-classified emails showing up?
- Who is receiving them?
- Which sender domains are associated?
- And whatâ€™s the volume per day per recipient per domain?

<br/>

Itâ€™s essentially a daily â€œmalware mail heatmap feedâ€ you can use for:
- spotting outbreaks (sudden day-over-day spikes)
- identifying repeated targeting patterns
- validating effectiveness of quarantine rules
- incident reporting (â€œwe quarantined X malware emails yesterdayâ€)

<br/><br/>

# Line-by-line technical breakdown ğŸ‘‡

## `EmailEvents`
Same base table as before: weâ€™re querying email telemetry at the message/event level. This is the right base for â€œhow many emails of type X happened.â€

<br/>

## `| where ThreatTypes has "Malware"`

Filter to only events where ThreatTypes includes the token "Malware".

What weâ€™re relying on
- This assumes the platformâ€™s classification labeled the email as malware-related.
- â€œMalwareâ€ here is a threat category label, not necessarily â€œwe confirmed execution happened.â€

### Why `has` again...
Same reason as phish: if ThreatTypes contains multiple values, has will still match when Malware is present.

<br/>

## `| summarize MalwareEmailsQuarantined = count() by bin(Timestamp, 1d), RecipientEmailAddress, SenderFromDomain`

This is doing three important things at once:

- 1.) `count()` â†’ a volume metric
    - MalwareEmailsQuarantined = count() counts the number of malware-labeled email event rows in each group.
    - We alias it to a human-readable metric name. Great.

<br/>

- 2.) `by RecipientEmailAddress, SenderFromDomain` â†’ who + from where

Just like our earlier phish pair query, we keep the two pivot keys:
- Recipient (target)
- Sender domain (apparent source)

That makes it immediately actionable.

<br/>

- 3.) `bin(Timestamp, 1d)` â†’ daily time-bucketing

This is the real â€œtrendâ€ part. Timestamp is the time field we're aggregating across. `bin(Timestamp, 1d)` rounds timestamps down into daily buckets (midnight boundaries in the queryâ€™s time context).

So instead of having scattered per-message timestamps, we get:
- 2025-12-16: recipientA + domainX = 12
- 2025-12-15: recipientA + domainX = 3
- etc.

That is perfect for:
- trending
- charting
- spotting â€œit started yesterdayâ€ patterns

<br/>

## `| order by Timestamp desc`

This sorts results so the newest day is at the top.

Important nuance: after summarizing, the Timestamp column is now the binned timestamp (the bucket start time). So ordering desc means:
- most recent day bucket first
- This is exactly what you want when scanning recent activity.
- What the output represents (plain English)

Each output row means: _â€œOn this day, this recipient received N malware-labeled emails associated with this sender domain.â€_

Itâ€™s not just â€œtop 10 offendersâ€ â€” itâ€™s a time series of malware email activity broken down by recipient and domain.

## Practical SOC use-cases

- Outbreak detection: _â€œWe jumped from 2/day to 40/day today â€” what changed?â€_
- Targeted malware campaigns: _â€œWhy is one mailbox repeatedly receiving malware payload emails?â€_
- Infrastructure clustering: _â€œIs the same sender domain showing up across multiple recipients day-over-day?â€_
- Reporting: _â€œHow many malware emails did we see and contain per day this week?â€_

<br/>

## âš¡ Steps to Operationalize:
- Detect trends, spikes, and delivery waves for malware-laden emails:
    - **Run cadence**: Daily (chart-based)
    - **Visualize**: Time-series dashboard showing:
        - Daily malware volume
        - Spikes vs baseline
    - **Baseline**: Establish normal daily malware volume per environment

<br/>

## âš”ï¸ SOC Actions:
- **Investigate spikes by:**
    - Sender domain
    - Attachment type
    - Malware family (if available)

<br/>

- **Correlate with:**
    - Endpoint alerts
    - User clicks
    - Device compromise indicators

<br/>

## ğŸ›¡ï¸ Defensive Controls to Trigger:
- Alert only on spikes, not absolute counts
- Increase attachment scanning or detonation during active waves
- Escalate incident severity if malware delivery aligns with endpoint detections

<br/>

ğŸ‘‰ **Outcome:** You stop reacting to â€œthere was malwareâ€ and start responding to malware campaigns, reducing alert noise and improving timing.

<br/>

![](/assets/img/KQL%20Toolbox/5/KQL5-5.png)

<br/><br/>

# ğŸ› ï¸ Operationalizing These Queries â€” with CIS & NIST Mapping

The real power of these queries isnâ€™t just detection â€” itâ€™s governance-aligned defense. When operationalized correctly, each query supports measurable outcomes in both
- CIS Critical Security Controls and
- NIST Cybersecurity Framework.

This section shows exactly how.

## ğŸ§­ The Big Picture: What These Queries Collectively Do

Together, these queries establish:
- Who is being targeted
- Who is doing the targeting
- How severe and persistent the activity is
- Whether it is escalating over time
- Whether payloads are transitioning from phish â†’ malware

That aligns directly with **Identify â†’ Detect â†’ Respond â†’ Improve** cycles in **NIST**, and **Continuous Monitoring + Email & Web Protections** in **CIS**.

<br/>

# ğŸ“Œ Query-by-Query Mapping & Operational Use
## 1ï¸âƒ£ Top Targeted Recipients (Recipient + Sender Domain)
Use Case: â€œWhich recipient + sender domain combinations represent the highest phishing pressure?â€

### Operational Value:
- Identifies specific attack paths, not just victims or domains in isolation
- Highlights campaign-level targeting patterns
- Drives fast containment decisions

### CIS Mapping:
- CIS 8.7 â€“ Email and Web Browser Protections
Detects malicious email patterns and enables tuning of email security controls
- CIS 13.1 â€“ Network Monitoring and Defense
Analyzes inbound attack activity to identify malicious infrastructure

### NIST CSF Mapping
- DE.AE-1 â€“ Anomalous activity is detected and analyzed
- DE.AE-2 â€“ Event data is aggregated and correlated from multiple sources

### How to Operationalize
- Run weekly and alert on new sender-domain + recipient pairs
- Prioritize blocking decisions based on repeated pairings
- Use output to justify transport rules or domain suppression

<br/><br/>

## 2ï¸âƒ£ Top Targeted Recipients (Recipient-Only Rollup)
Use Case: â€œWhich users are being targeted the most overall?â€

### Operational Value
- Identifies human risk concentration
- Surfaces unexpected targets (often compromised or externally visible users)
- Guides protective control escalation

### CIS Mapping
- CIS 6.3 â€“ Access Control Management
Prioritizes protection of accounts under active attack
- CIS 14.4 â€“ Security Awareness & Skills Training
Targets training where phishing exposure is highest

### NIST CSF Mapping
- ID.RA-1 â€“ Threats and vulnerabilities are identified
- PR.AA-1 â€“ Identities and credentials are managed and protected

### How to Operationalize
Escalate ğŸ”´ / ğŸ”¥ recipients into:
- stricter phishing policies
- enhanced MFA / conditional access
- mailbox rule audits

Use results to justify VIP mailbox protections

<br/><br/>

## 3ï¸âƒ£ Top Phishing Sender Domains (Domain-Only Rollup)
Use Case: â€œWhich sender domains are responsible for the most phishing volume?â€

### Operational Value
- Identifies repeat offender infrastructure
- Enables campaign suppression at scale
- Provides defensible evidence for domain blocks

### CIS Mapping
- CIS 8.7 â€“ Email and Web Browser Protections
Supports domain-based blocking and filtering
- CIS 15.1 â€“ Service Provider Management
Identifies external entities interacting maliciously with the organization

### NIST CSF Mapping
- DE.CM-1 â€“ Networks are monitored to detect potential cybersecurity events
- RS.MI-1 â€“ Incidents are contained

### How to Operationalize
- Alert when a domain crosses severity thresholds week-over-week
- Enrich with domain age and reputation
- Block aggressively once recurrence is established

<br/><br/>

## 4ï¸âƒ£ Malware Email Daily Trend (Bonus Query)
Use Case: â€œWhen malware emails appear, who receives them, from where, and how often?â€

### Operational Value
- Detects payload escalation
- Identifies outbreak patterns
- Enables incident-grade timelines

### CIS Mapping
- CIS 10.1 â€“ Malware Defenses
Detects and tracks malware delivery mechanisms
- CIS 8.8 â€“ DNS Filtering / Web Controls
Supports infrastructure-level mitigation

### NIST CSF Mapping
- DE.AE-3 â€“ Event data is analyzed to understand attack progression
- RS.AN-1 â€“ Investigation and analysis are performed

### How to Operationalize
- Alert on sudden day-over-day spikes
- Use as validation of email security effectiveness
- Attach results directly to incident reports

<br/>

![](/assets/img/KQL%20Toolbox/5/KQL5-6.png)

<br/><br/>

# ğŸ§  Closing Thoughts

With these mappings in place, you can confidently say: _â€œOur email threat detection directly supports CIS v8 controls and NIST CSF detection and response objectives â€” and we can prove it with telemetry.â€_

Thatâ€™s the difference between:

_â€œWe run some KQL queriesâ€_ and _â€œWe operate a standards-aligned email defense program.â€_

<br/>

As we wrap up KQL Toolbox #5, you now have a set of hunting queries that do more than just â€œcount emailsâ€ â€” they give you context, prioritization, and actionability on the two biggest threat vectors defenders face every day: phishing delivery and malware escalation. Youâ€™ve learned how to spot which mailboxes are being hammered, which domains are doing the hammering, and how malware-related deliveries trend over time. These queries arenâ€™t just analytics toy drills â€” theyâ€™re the start of a proactive hunt cycle that turns raw telemetry into defender decisions. In the next entry, weâ€™ll extend this further by operationalizing these patterns into alert rules and playbooks that close the loop from detect to respond, helping you build a more mature, measurable email threat defense program. Keep hunting â€” and donâ€™t just collect data, turn it into actionable insight.

<br/><br/>

# ğŸ“š Want to Go Deeper?

âš¡ If you like this kind of **practical KQL + cost-tuning** content, keep an eye on the **DevSecOpsDad KQL Toolbox** seriesâ€”and if you want the bigger picture across Defender, Sentinel, and Entra, my book *Ultimate Microsoft XDR for Full Spectrum Cyber Defense* goes even deeper with real-world examples, detections, and automation patterns.
&#128591; Huge thanks to everyone whoâ€™s already picked up a copy â€” and if youâ€™ve read it, a quick review on Amazon goes a long way!

![Ultimate Microsoft XDR for Full Spectrum Cyber Defense](/assets/img/Ultimate%20XDR%20for%20Full%20Spectrum%20Cyber%20Defense/cover11.jpg)

<br/><br/>

# ğŸ”— Helpful Links & Resources
- [ğŸ”— Query#1 â€” Top Blocked Phishing Events](https://github.com/EEN421/KQL-Queries/blob/Main/Top%20Blocked%20Phishing%20Events.kql)
- [ğŸ”— Query#2 â€” Top Phishing Targets](https://github.com/EEN421/KQL-Queries/blob/Main/Top%20Phishing%20Targets.kql)
- [ğŸ”— Query#3 â€” Top Phishing Domains](https://github.com/EEN421/KQL-Queries/blob/Main/Top%20Phishing%20Domains.kql)
- [ğŸ”— Query#4 â€” Top Blocked Malware Events](https://github.com/EEN421/KQL-Queries/blob/Main/Top%20Blocked%20Malware%20Email%20Events.kql)

<br/>

# âš¡Other Fun Stuff...
- [ğŸ› ï¸ Kql Toolbox #1: Track & Price Your Microsoft Sentinel Ingest Costs](https://www.hanley.cloud/2025-12-14-KQL-Toolbox-1-Track-&-Price-Your-Microsoft-Sentinel-Ingest-Costs/)
- [ğŸ§° Powershell Toolbox Part 1 Of 4: Azure Network Audit](https://www.hanley.cloud/2025-11-16-PowerShell-Toolbox-Part-1-of-4-Azure-Network-Audit/)
- [ğŸ§° Powershell Toolbox Part 2 Of 4: Azure Rbac Privileged Roles Audit](https://www.hanley.cloud/2025-11-19-PowerShell-Toolbox-Part-2-of-4-Azure-RBAC-Privileged-Roles-Audit/)
- [ğŸ§° Powershell Toolbox Part 3 Of 4: Gpo Html Export Script â€” Snapshot Every Group Policy Object In One Pass](https://www.hanley.cloud/2025-11-20-PowerShell-Toolbox-Part-3-of-4-GPO-HTML-Export-Script-Snapshot-Every-Group-Policy-Object-in-One-Pass/)
- [ğŸ§° Powershell Toolbox Part 4 Of 4: Audit Your Scripts With Invoke Scriptanalyzer](https://www.hanley.cloud/2025-11-24-PowerShell-Toolbox-Part-4-of-4-Audit-Your-Scripts-with-Invoke-ScriptAnalyzer/)

![DevSecOpsDad.com](/assets/img/NewFooter_DevSecOpsDad.png)
