ğŸ’¡ KQL Toolbox #5 â€” Phishing & Malware Hunting

## Today's KQL helps you identify â€œWhich recipients are getting hit with the most phishing emails, and which sender domains are responsible â€” with a quick severity label so I can triage fast?â€

It does that by:
- filtering email telemetry to phishing-tagged events,
- counting them per RecipientEmailAddress + SenderFromDomain,
- assigning â€œseverityâ€ buckets based on count thresholds,
- sorting and returning the top 10 highest-volume combos,
- formatting output for human readability.

### Full query 
```kql
// Identifies top recipients of phishing emails and categorizes severity based on volume

EmailEvents
| where ThreatTypes has "Phish"
| summarize PhishCount = count() by RecipientEmailAddress, SenderFromDomain
// Assign severity level indicators based on PhishCount
| extend SeverityIndicator = case(
                                 PhishCount >= 500,
                                 "ğŸ”¥ Extreme Volume",
                                 PhishCount >= 200,
                                 "ğŸ”´ Critical Volume",
                                 PhishCount >= 100,
                                 "ğŸŸ  Major Volume",
                                 PhishCount >= 50,
                                 "ğŸŸ¡ Moderate Volume",
                                 "ğŸŸ¢ Low Volume"
                             )
// Apply color coding to PhishCount
| extend CountColor = case(
                          PhishCount >= 500,
                          "ğŸ”¥",
                          PhishCount >= 200,
                          "ğŸ”´",
                          PhishCount >= 100,
                          "ğŸŸ ",
                          PhishCount >= 50,
                          "ğŸŸ¡",
                          "ğŸŸ¢"
                      )
// Sort by the highest volume of phishing emails received
| top 10 by PhishCount desc
// Improve column naming for readability
| project
    ["Recipient Email"] = RecipientEmailAddress, 
    ["Sender Domain"] = SenderFromDomain, 
    ["Phishing Emails Received"] = strcat(CountColor, " ", PhishCount),
    ["Severity"] = SeverityIndicator
```

# Line-by-line technical breakdown

`EmailEvents` --> This is your starting table.

In Microsoft Defender XDR advanced hunting, EmailEvents represents email message-level telemetry (think: â€œan email event existsâ€ plus metadata). Itâ€™s not attachment events and not URL click events â€” those are other tables (commonly EmailAttachmentInfo, EmailUrlInfo, etc., depending on schema).

Key point: youâ€™re starting at the event grain of â€œemail message activityâ€, which is appropriate for â€œvolume receivedâ€.

<br/>

`| where ThreatTypes has "Phish"` --> This filters the dataset down to only rows where the ThreatTypes field contains "Phish".

### Why `has`?

`has` is a token-based search operator. Itâ€™s optimized for â€œcontains word/tokenâ€. Itâ€™s usually a good fit when the field is a string that may contain multiple threat labels (e.g., Phish, Malware, Spam, etc.) or a semi-structured list. If ThreatTypes is something like "Phish;Spam" or "Spam, Phish", this will still match.

What this means operationally:
- Youâ€™re relying on whatever detection/classification pipeline populated ThreatTypes.
- This is not â€œuser reported phishâ€ by default; itâ€™s â€œthe system labeled this email as phish-relatedâ€.

### Gotcha

If your environment uses different labeling (example: â€œPhishingâ€ vs â€œPhishâ€), this filter may undercount.

If ThreatTypes can be empty or null sometimes, those simply wonâ€™t match.

`| summarize PhishCount = count() by RecipientEmailAddress, SenderFromDomain` --> This is the heart of the logic.

What `summarize` does:
- It groups rows by the fields listed after by.
- For each group, it calculates aggregations (here: count()).
- It outputs one row per group.

Weâ€™re grouping by TWO fields:
- `RecipientEmailAddress`
- `SenderFromDomain`

So the output is: â€œTop recipient + sender-domain pairsâ€

Thatâ€™s important: _**If one user gets 1,000 phish from 50 different domains (20 each), they will not appear as 1,000. Theyâ€™ll appear as many smaller rows.**_

Conversely, if one domain hammers one user repeatedly, that combo will jump to the top â€” which is usually what you want if youâ€™re trying to block/suppress a campaign source.

<br/>

`PhishCount = count()` --> `count()` counts rows in each group. Alias it as **PhishCount** for readability.

<br/>

`| extend SeverityIndicator = case( ... )` --> extend adds a new calculated column (or overwrites an existing one if the same name is used). Here, youâ€™re creating a string label based on thresholds.

How `case()` works in KQL:

`case(condition1, value1, condition2, value2, ..., defaultValue)` --> evaluates conditions in order:
- First match wins
- If none match, it returns the default.

Our logic:

```kql
PhishCount >= 500 â†’ "ğŸ”¥ Extreme Volume"

else if >= 200 â†’ "ğŸ”´ Critical Volume"

else if >= 100 â†’ "ğŸŸ  Major Volume"

else if >= 50 â†’ "ğŸŸ¡ Moderate Volume"

else â†’ "ğŸŸ¢ Low Volume"
```

### Why the order matters
If you put `PhishCount >= 50 first`, then a `PhishCount=500` row would match that first and never reach the â€œExtremeâ€ label. Our ordering is _highest threshold first._

### Why this is useful
Now your output can be read by humans quickly without doing mental math:

â€œOkay, thatâ€™s ğŸ”¥/ğŸ”´ â€” I should look at that first.â€

<br/>

`| extend CountColor = case( ... )` --> This is basically the same thresholds again, but returning a single emoji marker.

You now have:
- `SeverityIndicator` (emoji + label)
- `CountColor` (emoji only)

This is redundant on purpose because you use CountColor later to decorate the numeric count column.

> This is a common â€œSOC dashboard trickâ€: you donâ€™t need conditional formatting support if you embed the indicator into the string.

<br/>

`| top 10 by PhishCount desc` --> top is like `sort by ...` then `| take 10`, but optimized and concise.

- by PhishCount desc sorts highest first.
- top 10 returns only the first 10 rows.

ğŸ’¡ Important detail: This is â€œtop 10 recipient+domain pairsâ€ _after aggregation._ So the output is the 10 highest-volume hotspots.

<br/>>

`| project ...` --> project shapes the final output columns: _**rename, reorder, compute new display values,** and drop everything else._

We're doing four things here:

- 1) `["Recipient Email"] = RecipientEmailAddress`
    - Renames RecipientEmailAddress to â€œRecipient Emailâ€.
    - Square-bracket quoting is required because the column name contains spaces. This is KQLâ€™s friendly display-name style.

- 2) `["Sender Domain"] = SenderFromDomain`
    - Same idea: user-friendly heading.

- 3) `["Phishing Emails Received"] = strcat(CountColor, " ", PhishCount)`
    - This is the â€œpretty outputâ€ trick.
    - `strcat()` concatenates values into a string.
    - Put the emoji first, then a space, then the count.

So instead of 245, you get: "ğŸ”´ 245"

### Gotcha
Because this becomes a string, you canâ€™t sort numerically on this display column anymore. But you already sorted earlier using PhishCount, so youâ€™re fine. (If you ever wanted to chart this later, youâ€™d keep numeric PhishCount as a separate projected column too.)

- 4) ["Severity"] = SeverityIndicator
    - Final friendly severity label.
    - What the output actually represents
    - Each returned row means:
        - Recipient X received N phishing-labeled email events
        - specifically from Sender Domain Y
        - and N falls into a severity bucket

So this is extremely good for:
- spotting targeted users being hammered by a specific campaign domain
- identifying domains to block (or to investigate for spoofing / lookalike patterns)
- identifying users who might need extra protections/training (or are being specifically targeted)

<br/>

Practical SOC interpretation tips:

High volume to one recipient from one domain can indicate:
- a campaign repeatedly attempting delivery
- repeated re-sends with minor variations
- a compromised sender domain blasting the org
- a lookalike domain you should block fast

High volume spread across many domains might indicate:
- â€œrecipient is a public-facing mailboxâ€ (careers@, info@, support@)

======================================================================

<br/><br/><br/><br/>

Transition from the previous query **(Recipient + Sender Domain)** to this one **(Recipient-only)**

In the last query, we answered a very actionable question: â€œWhich recipient + sender domain pairs are generating the most phishing volume?â€ That pairing is clutch when youâ€™re trying to quickly identify a campaign source and decide what to block, quarantine, or hunt further.

But sometimes you need to zoom out and ask a simpler, more strategic question:

â€œWho are my top targeted users overall â€” regardless of where the phish is coming from?â€

Thatâ€™s exactly what this next query does. Instead of splitting counts across sender domains, it rolls everything up by recipient, giving you a clean â€œTop 10 most targeted mailboxesâ€ view thatâ€™s perfect for triage, VIP protection, training prioritization, and focus-based investigation.

# â€œWhich recipients are getting the most phishing emails (by volume), and how severe is the targeting?â€

```kql
// Identifies top recipients of phishing emails and categorizes severity based on volume

EmailEvents
| where ThreatTypes has "Phish"
| summarize PhishCount = count() by RecipientEmailAddress
// Assign severity level indicators based on PhishCount
| extend SeverityIndicator = case(
                                 PhishCount >= 500,
                                 "ğŸ”¥ Extreme Target",
                                 PhishCount >= 200,
                                 "ğŸ”´ Critical Target",
                                 PhishCount >= 100,
                                 "ğŸŸ  Major Target",
                                 PhishCount >= 50,
                                 "ğŸŸ¡ Moderate Target",
                                 "ğŸŸ¢ Low Target"
                             )
// Apply color coding to PhishCount
| extend CountColor = case(
                          PhishCount >= 500,
                          "ğŸ”¥",
                          PhishCount >= 200,
                          "ğŸ”´",
                          PhishCount >= 100,
                          "ğŸŸ ",
                          PhishCount >= 50,
                          "ğŸŸ¡",
                          "ğŸŸ¢"
                      )
// Sort by the highest volume of phishing emails received
| top 10 by PhishCount desc
// Improve column naming for readability
| project
    ["Recipient Email"] = RecipientEmailAddress, 
    ["Phishing Emails Received"] = strcat(CountColor, " ", PhishCount),
    ["Severity"] = SeverityIndicator
```

Itâ€™s a â€œwho is being targeted the mostâ€ ranking query â€” and itâ€™s intentionally recipient-centric, not campaign-centric.

## Line-by-line technical breakdown
// Identifies top recipients of phishing emails and categorizes severity based on volume

A comment to describe intent. In DevSecOpsDad land, this is the â€œwhy it existsâ€ line â€” helpful when your GitHub repo has dozens of queries and future-you needs context fast.

EmailEvents

This is your source table â€” the email telemetry backbone.

Each row represents an email-related event record with fields that can include:

sender / recipient addressing

delivery actions

threat classifications (like your ThreatTypes)

message metadata

Youâ€™re starting from the right place for volume-by-recipient analysis.

| where ThreatTypes has "Phish"

This is your filter: only phishing-labeled email events survive.

Why this matters

Everything downstream (counts, top 10, severity) is only as good as this filter.

Youâ€™re trusting the platformâ€™s classification pipeline that populates ThreatTypes.

Why has is used

It matches tokens inside a larger string (helpful if ThreatTypes contains multiple labels like "Phish;Spam").

Itâ€™s typically more efficient/appropriate than a fuzzy â€œcontains-likeâ€ approach when the field is token-ish.

| summarize PhishCount = count() by RecipientEmailAddress

This is the big change vs the previous query.

What summarize is doing

Groups all phishing events by RecipientEmailAddress

Counts how many phishing email events each recipient had

Outputs one row per recipient

What this solves
This gives you the true total volume per user.

So instead of:

Ian got 20 from domainA, 15 from domainB, 40 from domainCâ€¦

You now get:

Ian got 75 total phishing emails.

Operational win
This is excellent for:

identifying who needs extra protection (VIP mailbox, exec, finance/AP)

spotting mailboxes that are hammered (info@, jobs@, support@)

focusing investigations (â€œWhy is THIS one mailbox getting hit so hard?â€)

// Assign severity level indicators based on PhishCount

A clear marker: now we switch from measurement to classification.

| extend SeverityIndicator = case( ... )

Youâ€™re creating a severity label called SeverityIndicator.

Key mechanics

extend adds a new calculated column

case() evaluates conditions top-to-bottom (first match wins)

The last string is the default if none match

Your thresholds:

>= 500 â†’ ğŸ”¥ Extreme Target

>= 200 â†’ ğŸ”´ Critical Target

>= 100 â†’ ğŸŸ  Major Target

>= 50 â†’ ğŸŸ¡ Moderate Target

else â†’ ğŸŸ¢ Low Target

Why the order matters
This ordering is correct â€” highest threshold first â€” so a 600-count mailbox doesnâ€™t get accidentally labeled â€œModerateâ€.

Why the wording matters
You changed the label language from â€œVolumeâ€ to â€œTargetâ€ â€” thatâ€™s subtle but smart:

â€œVolumeâ€ implies â€œthereâ€™s a lotâ€

â€œTargetâ€ implies â€œsomeone is aiming at this recipientâ€
Thatâ€™s exactly the mindset you want readers to have.

// Apply color coding to PhishCount

Now youâ€™re building a quick visual indicator you can embed into the count column.

| extend CountColor = case( ... )

This repeats the same threshold logic, but returns a single emoji.

So later, you can build output like:

ğŸ”´ 245

ğŸŸ¡ 61

This is a â€œportable conditional formattingâ€ trick â€” especially handy when results are pasted into tickets, email, or screenshots.

// Sort by the highest volume of phishing emails received

Youâ€™re about to rank the hottest targets.

| top 10 by PhishCount desc

This returns only the 10 highest PhishCount recipients.

Why top is nice
Itâ€™s basically:

sort descending

take 10

â€¦and it does it efficiently.

Result expectation
This produces your â€œTop 10 targeted usersâ€ list.

// Improve column naming for readability

Now you convert technical column names into human-friendly headers.

| project ...

project is where you â€œfinalizeâ€ the output.

["Recipient Email"] = RecipientEmailAddress

Renames the column to a clean display name with spaces.

["Phishing Emails Received"] = strcat(CountColor, " ", PhishCount)

This builds a formatted string like:

ğŸ”¥ 612

ğŸŸ  143

Important nuance
This makes the displayed value a string. Thatâ€™s fine here because:

you already did your numeric sort using PhishCount

youâ€™re optimizing output for human consumption

["Severity"] = SeverityIndicator

Adds the labeled bucket you created earlier.

What the output represents (plain English)

Each row now means:

â€œThis recipient received N phishing-classified emails in the query time window (whatever your hunting UI defaults to), and N maps to this severity bucket.â€

This is a clean â€œwhoâ€™s getting hammeredâ€ scoreboard.
=================================================================================================================
Transition from â€œTop Targeted Recipientsâ€ â†’ â€œTop Threat Sender Domainsâ€

Now that weâ€™ve identified which mailboxes are being targeted most heavily, the next logical question is:

â€œOkayâ€¦ whoâ€™s doing the targeting at scale?â€

Because protecting users is only half the battle â€” the other half is shutting down the source. This next query flips the perspective from recipient-centric to threat-infrastructure-centric, showing you which sender domains are responsible for the most phishing volume across your entire environment. Thatâ€™s exactly the view you want for:

rapid domain blocking / allow-block policy decisions

threat intel enrichment and clustering

proving a campaignâ€™s scale in an incident summary (â€œthis domain hit us 800 times in 24 hoursâ€)

Full query (for reference)
// Identifies top phishing sender domains and categorizes severity based on volume

EmailEvents
| where ThreatTypes has "Phish"
| summarize PhishCount = count() by SenderFromDomain
// Assign severity level indicators based on PhishCount
| extend SeverityIndicator = case(
                                 PhishCount >= 1000,
                                 "ğŸ”¥ Extreme Threat Domain",
                                 PhishCount >= 500,
                                 "ğŸ”´ Critical Threat Domain",
                                 PhishCount >= 200,
                                 "ğŸŸ  Major Threat Domain",
                                 PhishCount >= 100,
                                 "ğŸŸ¡ Moderate Threat Domain",
                                 "ğŸŸ¢ Low Threat Domain"
                             )
// Apply color coding to PhishCount
| extend CountColor = case(
                          PhishCount >= 1000,
                          "ğŸ”¥",
                          PhishCount >= 500,
                          "ğŸ”´",
                          PhishCount >= 200,
                          "ğŸŸ ",
                          PhishCount >= 100,
                          "ğŸŸ¡",
                          "ğŸŸ¢"
                      )
// Sort by the highest volume of phishing emails sent from a domain
| top 10 by PhishCount desc
// Improve column naming for readability
| project
    ["Sender Domain"] = SenderFromDomain, 
    ["Phishing Emails Sent"] = strcat(CountColor, " ", PhishCount),
    ["Severity"] = SeverityIndicator

What this query is trying to answer

This query answers:

â€œWhich sender domains are responsible for the highest volume of phishing emails (as classified by the platform)?â€

Itâ€™s a â€œtop offender domainsâ€ query â€” ideal for finding repeat infrastructure and prioritizing blocking and investigation.

Line-by-line technical breakdown
// Identifies top phishing sender domains and categorizes severity based on volume

Comment describing intent. In a blog post, this sets expectations: weâ€™re no longer talking about targets â€” weâ€™re talking about sources.

EmailEvents

Your base email telemetry table again.

Same logic as before: this table is appropriate because weâ€™re counting email events and their threat classification at message level.

| where ThreatTypes has "Phish"

Filter down to phishing-labeled email events.

This keeps the analysis scoped to what the detection pipeline has already classified as phishing-related.

Why itâ€™s important here:
If you donâ€™t filter, youâ€™ll just get your â€œtop sender domains overallâ€ (which is usually dominated by normal business mail sources, marketing platforms, etc.). This where clause makes the output threat-focused.

| summarize PhishCount = count() by SenderFromDomain

This is the key shift.

What summarize does here

Groups all phishing email events by SenderFromDomain

Counts how many phishing-labeled events came from each sender domain

Outputs one row per sender domain

What this gives you
A ranked list of domains that show up repeatedly as the apparent sender domain in phishing-tagged emails.

Important nuance
This is â€œSenderFromDomainâ€ â€” which reflects the domain portion of the â€œFromâ€ identity as captured in telemetry. In real-world phishing:

the visible â€œFromâ€ domain can be spoofed

the envelope sender / return-path can differ

the sending infrastructure might be entirely different

So treat this output as:

highly actionable for â€œblock/suppressâ€ decisions, and

a starting pivot point, not the only truth.

| extend SeverityIndicator = case( ... )

Now you bucket severity again, but with thresholds tuned for domain-level volume.

Your thresholds are higher than the recipient query, and thatâ€™s logical:

A single mailbox getting 200 phish is bad

A single domain generating 500â€“1000 phish events org-wide is an â€œinfrastructure at scaleâ€ signal

Buckets:

>= 1000 â†’ ğŸ”¥ Extreme Threat Domain

>= 500 â†’ ğŸ”´ Critical Threat Domain

>= 200 â†’ ğŸŸ  Major Threat Domain

>= 100 â†’ ğŸŸ¡ Moderate Threat Domain

else â†’ ğŸŸ¢ Low Threat Domain

As before:

ordering matters (highest threshold first)

case() stops on first match

| extend CountColor = case( ... )

Same thresholds again, but returns only an emoji indicator.

This is purely for human scan-ability in the final table.

| top 10 by PhishCount desc

This ranks domains by highest phishing volume and returns the top 10.

This creates your â€œworst offendersâ€ list â€” the domains you should:

enrich with TI (reputation / age / registration)

see if they map to known campaigns

evaluate for blocking at mail gateway / Defender policies

| project ...

Final formatting and cleanup.

["Sender Domain"] = SenderFromDomain

Display-friendly renaming.

["Phishing Emails Sent"] = strcat(CountColor, " ", PhishCount)

This creates the formatted output string like:

ğŸ”¥ 1422

ğŸŸ  273

Again: string formatting is fine because sorting already happened on the numeric PhishCount.

["Severity"] = SeverityIndicator

Shows your bucket label.

What the output represents (plain English)

Each row means:

â€œThis sender domain appeared in N phishing-classified email events (in the query time window) across the environment â€” and hereâ€™s the severity bucket based on volume.â€

This is your top phishing domain offenders list.
======================================================================================================================
Bonus discussion transition: from Phish volume â†’ â€œOkayâ€¦ what about malware email?â€

Up to this point, weâ€™ve been treating phishing like a volume-and-targeting problem: whoâ€™s getting hammered, and which domains are doing the hammering. But in the real world, phish is often just the delivery vehicle â€” the â€œclick thisâ€ lure â€” while malware email is the â€œpayload problem.â€

So as a bonus lens, this next query pivots from phish targeting to:

â€œWhich recipients are receiving malware-labeled emails, from which domains, and how is that trending day-by-day?â€

Thatâ€™s a really practical add-on because itâ€™s inherently more â€œincident-yâ€ â€” malware emails tend to correlate more directly with containment actions and escalation.

Full query (for reference)
EmailEvents
| where ThreatTypes has "Malware"
| summarize MalwareEmailsQuarantined = count() by bin(Timestamp, 1d), RecipientEmailAddress, SenderFromDomain
| order by Timestamp desc

What this query is trying to answer

This query answers:

When (by day) are malware-classified emails showing up?

Who is receiving them?

Which sender domains are associated?

And whatâ€™s the volume per day per recipient per domain?

Itâ€™s essentially a daily â€œmalware mail heatmap feedâ€ you can use for:

spotting outbreaks (sudden day-over-day spikes)

identifying repeated targeting patterns

validating effectiveness of quarantine rules

incident reporting (â€œwe quarantined X malware emails yesterdayâ€)

Line-by-line technical breakdown
EmailEvents

Same base table as before: youâ€™re querying email telemetry at the message/event level.

This is the right base for â€œhow many emails of type X happened.â€

| where ThreatTypes has "Malware"

Filter to only events where ThreatTypes includes the token "Malware".

What youâ€™re relying on

This assumes the platformâ€™s classification labeled the email as malware-related.

â€œMalwareâ€ here is a threat category label, not necessarily â€œwe confirmed execution happened.â€

Why has again
Same reason as phish: if ThreatTypes contains multiple values, has will still match when Malware is present.

| summarize MalwareEmailsQuarantined = count() by bin(Timestamp, 1d), RecipientEmailAddress, SenderFromDomain

This is doing three important things at once:

1) count() â†’ a volume metric

MalwareEmailsQuarantined = count() counts the number of malware-labeled email event rows in each group.

You alias it to a human-readable metric name. Great.

Small naming nuance: the query itself does not explicitly check quarantine action â€” itâ€™s counting malware-labeled email events. If your environmentâ€™s pipeline only logs these when quarantined, then the name is accurate. If not, it may be slightly optimistic wording for a blog post. (More on this in â€œGotchasâ€ below.)

2) by RecipientEmailAddress, SenderFromDomain â†’ who + from where

Just like your earlier phish pair query, you keep the two pivot keys:

Recipient (target)

Sender domain (apparent source)

That makes it immediately actionable.

3) bin(Timestamp, 1d) â†’ daily time-bucketing

This is the real â€œtrendâ€ part.

Timestamp is the time field youâ€™re aggregating across.

bin(Timestamp, 1d) rounds timestamps down into daily buckets (midnight boundaries in the queryâ€™s time context).

So instead of having scattered per-message timestamps, you get:

2025-12-16: recipientA + domainX = 12

2025-12-15: recipientA + domainX = 3

etc.

That is perfect for:

trending

charting

spotting â€œit started yesterdayâ€ patterns

| order by Timestamp desc

This sorts results so the newest day is at the top.

Important nuance: after summarizing, the Timestamp column is now the binned timestamp (the bucket start time). So ordering desc means:

most recent day bucket first

This is exactly what you want when scanning recent activity.

What the output represents (plain English)

Each output row means:

â€œOn this day, this recipient received N malware-labeled emails associated with this sender domain.â€

Itâ€™s not just â€œtop 10 offendersâ€ â€” itâ€™s a time series of malware email activity broken down by recipient and domain.

Practical SOC use-cases

Outbreak detection: â€œWe jumped from 2/day to 40/day today â€” what changed?â€

Targeted malware campaigns: â€œWhy is one mailbox repeatedly receiving malware payload emails?â€

Infrastructure clustering: â€œIs the same sender domain showing up across multiple recipients day-over-day?â€

Reporting: â€œHow many malware emails did we see and contain per day this week?â€
===================================================================================================
ğŸ› ï¸ Operationalizing These Queries â€” with CIS & NIST Mapping

The real power of these queries isnâ€™t just detection â€” itâ€™s governance-aligned defense.

When operationalized correctly, each query supports measurable outcomes in both
CIS Critical Security Controls and
NIST Cybersecurity Framework.

This section shows exactly how.

ğŸ§­ The Big Picture: What These Queries Collectively Do

Together, your queries establish:

Who is being targeted

Who is doing the targeting

How severe and persistent the activity is

Whether it is escalating over time

Whether payloads are transitioning from phish â†’ malware

That aligns directly with Identify â†’ Detect â†’ Respond â†’ Improve cycles in NIST, and Continuous Monitoring + Email & Web Protections in CIS.

ğŸ“Œ Query-by-Query Mapping & Operational Use
1ï¸âƒ£ Top Targeted Recipients (Recipient + Sender Domain)

â€œWhich recipient + sender domain combinations represent the highest phishing pressure?â€

Operational Value

Identifies specific attack paths, not just victims or domains in isolation

Highlights campaign-level targeting patterns

Drives fast containment decisions

CIS Mapping

CIS 8.7 â€“ Email and Web Browser Protections
Detects malicious email patterns and enables tuning of email security controls

CIS 13.1 â€“ Network Monitoring and Defense
Analyzes inbound attack activity to identify malicious infrastructure

NIST CSF Mapping

DE.AE-1 â€“ Anomalous activity is detected and analyzed

DE.AE-2 â€“ Event data is aggregated and correlated from multiple sources

How to Operationalize

Run weekly and alert on new sender-domain + recipient pairs

Prioritize blocking decisions based on repeated pairings

Use output to justify transport rules or domain suppression

2ï¸âƒ£ Top Targeted Recipients (Recipient-Only Rollup)

â€œWhich users are being targeted the most overall?â€

Operational Value

Identifies human risk concentration

Surfaces unexpected targets (often compromised or externally visible users)

Guides protective control escalation

CIS Mapping

CIS 6.3 â€“ Access Control Management
Prioritizes protection of accounts under active attack

CIS 14.4 â€“ Security Awareness & Skills Training
Targets training where phishing exposure is highest

NIST CSF Mapping

ID.RA-1 â€“ Threats and vulnerabilities are identified

PR.AA-1 â€“ Identities and credentials are managed and protected

How to Operationalize

Escalate ğŸ”´ / ğŸ”¥ recipients into:

stricter phishing policies

enhanced MFA / conditional access

mailbox rule audits

Use results to justify VIP mailbox protections

3ï¸âƒ£ Top Phishing Sender Domains (Domain-Only Rollup)

â€œWhich sender domains are responsible for the most phishing volume?â€

Operational Value

Identifies repeat offender infrastructure

Enables campaign suppression at scale

Provides defensible evidence for domain blocks

CIS Mapping

CIS 8.7 â€“ Email and Web Browser Protections
Supports domain-based blocking and filtering

CIS 15.1 â€“ Service Provider Management
Identifies external entities interacting maliciously with the organization

NIST CSF Mapping

DE.CM-1 â€“ Networks are monitored to detect potential cybersecurity events

RS.MI-1 â€“ Incidents are contained

How to Operationalize

Alert when a domain crosses severity thresholds week-over-week

Enrich with domain age and reputation

Block aggressively once recurrence is established

4ï¸âƒ£ Malware Email Daily Trend (Bonus Query)

â€œWhen malware emails appear, who receives them, from where, and how often?â€

Operational Value

Detects payload escalation

Identifies outbreak patterns

Enables incident-grade timelines

CIS Mapping

CIS 10.1 â€“ Malware Defenses
Detects and tracks malware delivery mechanisms

CIS 8.8 â€“ DNS Filtering / Web Controls
Supports infrastructure-level mitigation

NIST CSF Mapping

DE.AE-3 â€“ Event data is analyzed to understand attack progression

RS.AN-1 â€“ Investigation and analysis are performed

How to Operationalize

Alert on sudden day-over-day spikes

Use as validation of email security effectiveness

Attach results directly to incident reports

ğŸ” Continuous Improvement Loop (Governance-Aligned)
CIS Alignment

CIS 4.1 â€“ Secure Configuration Monitoring

CIS 13.2 â€“ Continuous Monitoring

NIST Alignment

ID.GV-1 â€“ Cybersecurity risk management processes are established

PR.IP-7 â€“ Protection processes are improved

What This Looks Like in Practice

Review thresholds every 30â€“60 days

Track which queries generate real incidents

Adjust severity cutoffs as email volume changes

Retire rules that no longer provide value

ğŸ§  Executive-Ready Framing (Why This Matters)

With these mappings in place, you can confidently say:

â€œOur email threat detection directly supports CIS v8 controls and NIST CSF detection and response objectives â€” and we can prove it with telemetry.â€

Thatâ€™s the difference between:

â€œWe run some KQL queriesâ€
and

â€œWe operate a standards-aligned email defense program.â€

<br/><br/>

# ğŸ“š Want to Go Deeper?

âš¡ If you like this kind of **practical KQL + cost-tuning** content, keep an eye on the **DevSecOpsDad KQL Toolbox** seriesâ€”and if you want the bigger picture across Defender, Sentinel, and Entra, my book *Ultimate Microsoft XDR for Full Spectrum Cyber Defense* goes even deeper with real-world examples, detections, and automation patterns.
&#128591; Huge thanks to everyone whoâ€™s already picked up a copy â€” and if youâ€™ve read it, a quick review on Amazon goes a long way!

![Ultimate Microsoft XDR for Full Spectrum Cyber Defense](/assets/img/Ultimate%20XDR%20for%20Full%20Spectrum%20Cyber%20Defense/cover11.jpg)

<br/><br/>

# ğŸ”— Helpful Links & Resources
- [ğŸ› ï¸ Kql Toolbox #1: Track & Price Your Microsoft Sentinel Ingest Costs](https://www.hanley.cloud/2025-12-14-KQL-Toolbox-1-Track-&-Price-Your-Microsoft-Sentinel-Ingest-Costs/)


<br/>

# âš¡Other Fun Stuff...
- [ğŸ§° Powershell Toolbox Part 1 Of 4: Azure Network Audit](https://www.hanley.cloud/2025-11-16-PowerShell-Toolbox-Part-1-of-4-Azure-Network-Audit/)
- [ğŸ§° Powershell Toolbox Part 2 Of 4: Azure Rbac Privileged Roles Audit](https://www.hanley.cloud/2025-11-19-PowerShell-Toolbox-Part-2-of-4-Azure-RBAC-Privileged-Roles-Audit/)
- [ğŸ§° Powershell Toolbox Part 3 Of 4: Gpo Html Export Script â€” Snapshot Every Group Policy Object In One Pass](https://www.hanley.cloud/2025-11-20-PowerShell-Toolbox-Part-3-of-4-GPO-HTML-Export-Script-Snapshot-Every-Group-Policy-Object-in-One-Pass/)
- [ğŸ§° Powershell Toolbox Part 4 Of 4: Audit Your Scripts With Invoke Scriptanalyzer](https://www.hanley.cloud/2025-11-24-PowerShell-Toolbox-Part-4-of-4-Audit-Your-Scripts-with-Invoke-ScriptAnalyzer/)

![DevSecOpsDad.com](/assets/img/NewFooter_DevSecOpsDad.png)