What this query is trying to answer

This query is designed to answer:

â€œWhich recipients are getting hit with the most phishing emails, and which sender domains are responsible â€” with a quick severity label so I can triage fast?â€

It does that by:

filtering email telemetry to phishing-tagged events,

counting them per RecipientEmailAddress + SenderFromDomain,

assigning â€œseverityâ€ buckets based on count thresholds,

sorting and returning the top 10 highest-volume combos,

formatting output for human readability.

Full query (for reference)
// Identifies top recipients of phishing emails and categorizes severity based on volume

EmailEvents
| where ThreatTypes has "Phish"
| summarize PhishCount = count() by RecipientEmailAddress, SenderFromDomain
// Assign severity level indicators based on PhishCount
| extend SeverityIndicator = case(
                                 PhishCount >= 500,
                                 "ğŸ”¥ Extreme Volume",
                                 PhishCount >= 200,
                                 "ğŸ”´ Critical Volume",
                                 PhishCount >= 100,
                                 "ğŸŸ  Major Volume",
                                 PhishCount >= 50,
                                 "ğŸŸ¡ Moderate Volume",
                                 "ğŸŸ¢ Low Volume"
                             )
// Apply color coding to PhishCount
| extend CountColor = case(
                          PhishCount >= 500,
                          "ğŸ”¥",
                          PhishCount >= 200,
                          "ğŸ”´",
                          PhishCount >= 100,
                          "ğŸŸ ",
                          PhishCount >= 50,
                          "ğŸŸ¡",
                          "ğŸŸ¢"
                      )
// Sort by the highest volume of phishing emails received
| top 10 by PhishCount desc
// Improve column naming for readability
| project
    ["Recipient Email"] = RecipientEmailAddress, 
    ["Sender Domain"] = SenderFromDomain, 
    ["Phishing Emails Received"] = strcat(CountColor, " ", PhishCount),
    ["Severity"] = SeverityIndicator

Line-by-line technical breakdown
// Identifies top recipients of phishing emails and categorizes severity based on volume

A comment. KQL ignores it. But it matters for humans and for future-you.

If you keep queries in GitHub (like you do), these comments are gold when you come back later.

EmailEvents

This is your starting table.

In Microsoft Defender XDR advanced hunting, EmailEvents represents email message-level telemetry (think: â€œan email event existsâ€ plus metadata). Itâ€™s not attachment events and not URL click events â€” those are other tables (commonly EmailAttachmentInfo, EmailUrlInfo, etc., depending on schema).

Key point: youâ€™re starting at the event grain of â€œemail message activityâ€, which is appropriate for â€œvolume receivedâ€.

| where ThreatTypes has "Phish"

This filters the dataset down to only rows where the ThreatTypes field contains "Phish".

Why has?

has is a token-based search operator. Itâ€™s optimized for â€œcontains word/tokenâ€.

Itâ€™s usually a good fit when the field is a string that may contain multiple threat labels (e.g., Phish, Malware, Spam, etc.) or a semi-structured list.

If ThreatTypes is something like "Phish;Spam" or "Spam, Phish", this will still match.

What this means operationally

Youâ€™re relying on whatever detection/classification pipeline populated ThreatTypes.

This is not â€œuser reported phishâ€ by default; itâ€™s â€œthe system labeled this email as phish-relatedâ€.

Gotcha

If your environment uses different labeling (example: â€œPhishingâ€ vs â€œPhishâ€), this filter may undercount.

If ThreatTypes can be empty or null sometimes, those simply wonâ€™t match.

| summarize PhishCount = count() by RecipientEmailAddress, SenderFromDomain

This is the heart of the logic.

What summarize does

It groups rows by the fields listed after by.

For each group, it calculates aggregations (here: count()).

It outputs one row per group.

Youâ€™re grouping by TWO fields

RecipientEmailAddress

SenderFromDomain

So the output isnâ€™t â€œtop recipients overallâ€.
Itâ€™s:

â€œTop recipient + sender-domain pairsâ€

Thatâ€™s important:

If one user gets 1,000 phish from 50 different domains (20 each), they will not appear as 1,000. Theyâ€™ll appear as many smaller rows.

Conversely, if one domain hammers one user repeatedly, that combo will jump to the top â€” which is usually what you want if youâ€™re trying to block/suppress a campaign source.

PhishCount = count()

count() counts rows in each group.

You alias it as PhishCount for readability.

// Assign severity level indicators based on PhishCount

Another comment â€” and it signals youâ€™re about to convert the raw number into triage categories.

| extend SeverityIndicator = case( ... )

extend adds a new calculated column (or overwrites an existing one if the same name is used).

Here, youâ€™re creating a string label based on thresholds.

How case() works in KQL

case(condition1, value1, condition2, value2, ..., defaultValue)

It evaluates conditions in order.

First match wins.

If none match, it returns the default.

Your logic:

PhishCount >= 500 â†’ "ğŸ”¥ Extreme Volume"

else if >= 200 â†’ "ğŸ”´ Critical Volume"

else if >= 100 â†’ "ğŸŸ  Major Volume"

else if >= 50 â†’ "ğŸŸ¡ Moderate Volume"

else â†’ "ğŸŸ¢ Low Volume"

Why the order matters
If you put PhishCount >= 50 first, then a PhishCount=500 row would match that first and never reach the â€œExtremeâ€ label. Your ordering is correct: highest threshold first.

Why this is useful
Now your output can be read by humans quickly without doing mental math:

â€œOkay, thatâ€™s ğŸ”¥/ğŸ”´ â€” I should look now.â€

// Apply color coding to PhishCount

Youâ€™re about to create a separate â€œvisual markerâ€ column.

| extend CountColor = case( ... )

This is basically the same thresholds again, but returning a single emoji marker.

You now have:

SeverityIndicator (emoji + label)

CountColor (emoji only)

This is redundant on purpose because you use CountColor later to decorate the numeric count column.

Thatâ€™s a common â€œSOC dashboard trickâ€: you donâ€™t need conditional formatting support if you embed the indicator into the string.

// Sort by the highest volume of phishing emails received

Comment describing the next operator.

| top 10 by PhishCount desc

top is like sort by ... | take N, but optimized and concise.

by PhishCount desc sorts highest first.

top 10 returns only the first 10 rows.

Important detail
This is â€œtop 10 recipient+domain pairsâ€ after aggregation.

So your output is the 10 highest-volume hotspots.

// Improve column naming for readability

Comment â€” and your project does exactly that.

| project ...

project shapes the final output columns: rename, reorder, compute new display values, and drop everything else.

Youâ€™re doing four things here:

1) ["Recipient Email"] = RecipientEmailAddress

Renames RecipientEmailAddress to â€œRecipient Emailâ€.

Square-bracket quoting is required because the column name contains spaces. This is KQLâ€™s friendly display-name style.

2) ["Sender Domain"] = SenderFromDomain

Same idea: user-friendly heading.

3) ["Phishing Emails Received"] = strcat(CountColor, " ", PhishCount)

This is the â€œpretty outputâ€ trick.

strcat() concatenates values into a string.

You put the emoji first, then a space, then the count.

So instead of 245, you get:

ğŸ”´ 245

Gotcha
Because this becomes a string, you canâ€™t sort numerically on this display column anymore. But you already sorted earlier using PhishCount, so youâ€™re fine.

(If you ever wanted to chart this later, youâ€™d keep numeric PhishCount as a separate projected column too.)

4) ["Severity"] = SeverityIndicator

Final friendly severity label.

What the output actually represents

Each returned row means:

Recipient X received N phishing-labeled email events

specifically from Sender Domain Y

and N falls into a severity bucket

So this is extremely good for:

spotting targeted users being hammered by a specific campaign domain

identifying domains to block (or to investigate for spoofing / lookalike patterns)

identifying users who might need extra protections/training (or are being specifically targeted)

Practical SOC interpretation tips

High volume to one recipient from one domain can indicate:

a campaign repeatedly attempting delivery

repeated re-sends with minor variations

a compromised sender domain blasting the org

a lookalike domain you should block fast

High volume spread across many domains might indicate:

â€œrecipient is a public-facing mailboxâ€ (careers@, info@, support@)

your query may need â€œmailbox typeâ€ context before you treat it as risk
